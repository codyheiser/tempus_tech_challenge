<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import requests, sys
import vcf

import pandas as pd


def split_vals(d, key, list_delim=&#34;;&#34;):
    &#34;&#34;&#34;
    Given a dictionary and key within it, split values into multiple keys

    Parameters
    ----------
    d : `dict`
        Dictionary
    key : `str`
        Key within `d` to split
    list_delim : `str`, optional (default=&#34;;&#34;)
        String to delimit list values in `d[key]` with

    Returns
    -------
    d : `dict`
        Dictionary with split values
    &#34;&#34;&#34;
    assert list_delim in d[key], &#34;Key {} does not contain delimiter {}&#34;.format(
        key, list_delim
    )
    vals = d[key].split(list_delim)  # list of split values
    d[key] = vals[0]  # original key gets first value
    for i, val in enumerate(vals[1:]):
        # add key1, key2, etc. and corresponding values
        d[&#34;{}{}&#34;.format(key, i + 1)] = val


def unpack_dict(d, list_delim=&#34;;&#34;, verbose=False, indent=&#34;&#34;):
    &#34;&#34;&#34;
    Given a dictionary, unpack values such that lists become singular.
    Intended to prep dictionaries for pandas compatibility.

    Parameters
    ----------
    d : `dict`
        Dictionary to unpack
    list_delim : `str`, optional (default=&#34;;&#34;)
        String to delimit list values in `d` with
    verbose : `bool`, optional (default=`False`)
        If `True`, print information when values are unpacked
    indent : `str`, optional (default=&#34;&#34;)
        For pretty traceback. Ignored if `verbose==False`.

    Returns
    -------
    d_unpacked : `dict`
        Dictionary with unpacked values
    &#34;&#34;&#34;
    d_unpacked = d.copy()
    for key in d:
        if isinstance(d[key], list):
            # if key is a list, do some unpacking
            if len(d[key]) &gt; 1:
                # if value is list, join by list_delim
                d_unpacked[key] = [str(elem) for elem in d_unpacked[key]]
                d_unpacked[key] = list_delim.join(d_unpacked[key])
                if verbose:
                    print(
                        &#34;{}Joining key {} using delimiter {}&#34;.format(
                            indent, key, list_delim
                        )
                    )
            elif len(d_unpacked[key]) == 1:
                # if value is list with one element, unpack
                d_unpacked[key] = d_unpacked[key][0]
                if verbose:
                    print(
                        &#34;{}Unpacked 1 value from key {}: {}&#34;.format(
                            indent, key, d_unpacked[key]
                        )
                    )
            else:
                # if empty list (for some reason), remove the key
                del d_unpacked[key]
        elif isinstance(d[key], dict):
            # if key is another dict, do full unpacking
            if verbose:
                print(
                    &#34;{}Unpacking key {} as dictionary with {} keys&#34;.format(
                        indent, key, len(d_unpacked[key])
                    )
                )
            # generate new keys from dict
            unpacked_key = unpack_dict(
                d_unpacked[key],
                list_delim=list_delim,
                verbose=verbose,
                indent=&#34;{}\t&#34;.format(indent),
            )
            # delete original key-value pair
            del d_unpacked[key]
            # merge the two dicts
            d_unpacked = {**d_unpacked, **unpacked_key}
            if verbose:
                print(&#34;{}\tAdded {} keys to dict&#34;.format(indent, len(unpacked_key)))
        elif d[key] is None:
            # if empty value, just remove it
            del d_unpacked[key]

    return d_unpacked


def extract_call(call_obj, format_str=&#34;GT:GL:GOF:GQ:NR:NV&#34;, format_delim=&#34;:&#34;):
    &#34;&#34;&#34;
    Given a `vcf.model._Call` object, unpack values into dictionary

    Parameters
    ----------
    call_obj : `vcf.model._Call`
        PyVCF `model._Call` object to extract information from
    format_str : `str`, optional (default=&#34;GT:GL:GOF:GQ:NR:NV&#34;)
        String describing format of `vcf.model._Call` object, and keys present
    format_delim : `str`, optional (default=&#34;:&#34;)
        String to delimit list values in `format_str` with

    Returns
    -------
    call_dict : `dict`
        Dictionary with unpacked values from `call_obj`
    &#34;&#34;&#34;
    assert isinstance(
        call_obj, vcf.model._Call
    ), &#34;call_obj must be a vcf.model._Call object&#34;
    call_dict = {}  # initialize empty dictionary
    keys = format_str.split(format_delim)  # list of expected keys in call_obj
    for key in keys:
        call_dict[key] = getattr(call_obj.data, key)

    return call_dict


def extract_alt(d, alt_obj, alt_key=&#34;ALT&#34;):
    &#34;&#34;&#34;
    Given a dictionary containing `vcf.model._Substitution` object, unpack
    values into dictionary

    Parameters
    ----------
    d : `dict`
        Dictionary with &#34;ALT&#34; key to unpack
    alt_obj : `vcf.model._Substitution` or `list`
        PyVCF `vcf.model._Substitution` object to extract information from
        (i.e. `record.ALT`)
    alt_key : `str`, optional (default=&#34;ALT&#34;)
        key within `d` containing PyVCF `model._Substitution` object

    Returns
    -------
    d_unpacked : `dict`
        Dictionary with unpacked values
    &#34;&#34;&#34;
    d_unpacked = d.copy()

    if isinstance(alt_obj, vcf.model._Substitution):
        # get variant type from alt_key
        d_unpacked[&#34;{}_type&#34;.format(alt_key)] = alt_obj.type
        # get variant sequence as string and replace alt_key
        d_unpacked[alt_key] = alt_obj.sequence
    elif isinstance(alt_obj, list):
        # unpack list of ALTs
        d_unpacked[&#34;{}_type&#34;.format(alt_key)] = &#34;;&#34;.join([x.type for x in alt_obj])
        d_unpacked[alt_key] = &#34;;&#34;.join([x.sequence for x in alt_obj])
    else:
        print(&#34;alt_obj is not a list or vcf.model._Substitution object; skipping.&#34;)

    return d_unpacked


def vep_region_post(
    record,
    server=&#34;https://grch37.rest.ensembl.org&#34;,
    ext=&#34;/vep/homo_sapiens/region&#34;,
    **kwargs,
):
    &#34;&#34;&#34;
    Given a `vcf.model._Record` object, send POST request to Ensembl
    vep/:species/region

    Parameters
    ----------
    record : `vcf.model._Record`
        PyVCF `model._Record` object to send to Ensembl API
    server : `str`, optional (default=&#34;https://grch37.rest.ensembl.org&#34;)
        URL to Ensembl server
    ext : `str`, optional (default=&#34;/vep/homo_sapiens/region&#34;)
        URL extension for region annotation endpoint
    **kwargs
        Keyword arguments for VEP endpoint

    Returns
    -------
    vep_dict : `dict`
        Dictionary with returned values from Ensembl API call
    &#34;&#34;&#34;
    assert isinstance(
        record, vcf.model._Record
    ), &#34;record must be a vcf.model._Record object&#34;
    headers = {&#34;Content-Type&#34;: &#34;application/json&#34;, &#34;Accept&#34;: &#34;application/json&#34;}
    r = requests.post(
        server + ext,
        headers=headers,
        data=&#39;{{ &#34;variants&#34; : [&#34;{} {} {} {} {} . . .&#34;], {} }}&#39;.format(
            record.CHROM,
            record.POS,
            record.ID if record.ID is not None else &#34;.&#34;,
            record.REF,
            record.ALT[0].sequence,
            str(kwargs).replace(&#34;{&#34;, &#34;&#34;).replace(&#34;}&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#39;&#34;&#39;),
        ),
    )

    if not r.ok:
        r.raise_for_status()
        sys.exit()

    vep_dict = r.json()
    assert len(vep_dict) == 1, &#34;More than one VEP result returned!&#34;
    return vep_dict[0]


def overlap_get(record, server=&#34;https://grch37.rest.ensembl.org&#34;):
    &#34;&#34;&#34;
    Given a `vcf.model._Record` object, send POST request to Ensembl
    vep/:species/region

    Parameters
    ----------
    record : `vcf.model._Record`
        PyVCF `model._Record` object to send to Ensembl API
    server : `str`, optional (default=&#34;https://grch37.rest.ensembl.org&#34;)
        URL to Ensembl server

    Returns
    -------
    overlap_dict : `dict`
        Dictionary with returned values from Ensembl API call
    &#34;&#34;&#34;
    assert isinstance(
        record, vcf.model._Record
    ), &#34;record must be a vcf.model._Record object&#34;
    ext = &#34;/overlap/region/homo_sapiens/{}:{}-{}?feature=gene&#34;.format(
        record.CHROM,
        record.start,
        record.end,
    )
    headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}
    r = requests.get(server + ext, headers=headers)

    if not r.ok:
        r.raise_for_status()
        sys.exit()

    overlap_dict = r.json()
    return overlap_dict


def process_record(record, index=1):
    &#34;&#34;&#34;
    Given a `vcf.model._Record` object, annotate it and return as a dataframe

    Parameters
    ----------
    record : `vcf.model._Record`
        PyVCF `model._Record` object to annotate
    index : `int`, optional (default=1)
        Index of resulting `pd.DataFrame`

    Returns
    -------
    record_unpacked : `pd.DataFrame`
        Annotated dataframe row corresponding to `record`
    &#34;&#34;&#34;
    # unpack record into dictionary of depth 1
    record_unpacked = unpack_dict(record.__dict__)
    # unpack ALT allele objects
    record_unpacked = extract_alt(record_unpacked, alt_obj=record.ALT, alt_key=&#34;ALT&#34;)
    # unpack model._Call object
    call_dict = unpack_dict(
        extract_call(record_unpacked[&#34;samples&#34;], format_str=record_unpacked[&#34;FORMAT&#34;]),
    )
    # remove old keys
    del record_unpacked[&#34;samples&#34;]
    del record_unpacked[&#34;FORMAT&#34;]
    # merge dicts
    record_unpacked = {**record_unpacked, **call_dict}

    # get gene where mutation is
    overlap_dict = overlap_get(record)
    try:
        # first record
        record_unpacked[&#34;gene_id&#34;] = overlap_dict[0][&#34;gene_id&#34;]
        record_unpacked[&#34;gene_symbol&#34;] = overlap_dict[0][&#34;external_name&#34;]
        record_unpacked[&#34;gene_biotype&#34;] = overlap_dict[0][&#34;biotype&#34;]
        record_unpacked[&#34;gene_description&#34;] = overlap_dict[0][&#34;description&#34;]
        if len(overlap_dict) &gt; 1:
            for i in range(1, len(overlap_dict)):
                record_unpacked[&#34;gene_id{}&#34;.format(i)] = overlap_dict[i][&#34;gene_id&#34;]
                record_unpacked[&#34;gene_symbol{}&#34;.format(i)] = overlap_dict[i][
                    &#34;external_name&#34;
                ]
                record_unpacked[&#34;gene_biotype{}&#34;.format(i)] = overlap_dict[i][&#34;biotype&#34;]
                record_unpacked[&#34;gene_description{}&#34;.format(i)] = overlap_dict[i][
                    &#34;description&#34;
                ]
    except:
        print(&#34;No gene overlap found for {}&#34;.format(record))

    # call Ensembl VEP endpoint
    vep_dict = vep_region_post(
        record,
        hgvs=1,
        # protein=1,
        # uniprot=1,
        # GO=1,
        # vcf_string=1,
        # domains=1,
        distance=0,  # don&#39;t look for upstream/downstream effects for simplicity
    )
    # extract VEP info
    record_unpacked[&#34;most_severe_consequence&#34;] = vep_dict[&#34;most_severe_consequence&#34;]

    # get MAF and snp info if available
    if &#34;colocated_variants&#34; in vep_dict:
        for d in vep_dict[&#34;colocated_variants&#34;]:
            if &#34;minor_allele&#34; in d:
                record_unpacked[&#34;minor_allele&#34;] = d[&#34;minor_allele&#34;]
                record_unpacked[&#34;minor_allele_freq&#34;] = d[&#34;minor_allele_freq&#34;]
                record_unpacked[&#34;snp_id&#34;] = d[&#34;id&#34;]

    return pd.DataFrame(record_unpacked, index=[index])


def calc_frequencies(out_df):
    &#34;&#34;&#34;
    Calculate variant and reference allele frequencies (VAF and RAF)

    Parameters
    ----------
    out_df : `pd.DataFrame`
        DataFrame containing annotations and columns `[&#34;NR&#34;,&#34;NV&#34;]`

    Returns
    -------
    `out_df` is edited in place, adding &#34;NRef&#34;, &#34;VAF&#34; and &#34;RAF&#34; columns
    &#34;&#34;&#34;
    # split values if needed
    if out_df.NR.astype(str).str.contains(&#34;;&#34;).any():
        out_df[[&#34;NR&#34;, &#34;NR1&#34;]] = out_df[&#34;NR&#34;].astype(str).str.split(&#34;;&#34;, expand=True)
        out_df[[&#34;NV&#34;, &#34;NV1&#34;]] = out_df[&#34;NV&#34;].astype(str).str.split(&#34;;&#34;, expand=True)

        out_df[&#34;VAF&#34;] = out_df[&#34;NV&#34;].astype(int) / out_df[&#34;NR&#34;].astype(int)
        out_df[&#34;NRef&#34;] = out_df[&#34;NR&#34;].astype(int) - out_df[&#34;NV&#34;].astype(int)
        out_df[&#34;RAF&#34;] = out_df[&#34;NRef&#34;] / out_df[&#34;NR&#34;].astype(int)

        out_df.loc[~out_df.NR1.isnull(), &#34;VAF1&#34;] = out_df.loc[
            ~out_df.NR1.isnull(), &#34;NV1&#34;
        ].astype(int) / out_df.loc[~out_df.NR1.isnull(), &#34;NR1&#34;].astype(int)
        out_df.loc[~out_df.NR1.isnull(), &#34;NRef1&#34;] = out_df.loc[
            ~out_df.NR1.isnull(), &#34;NR1&#34;
        ].astype(int) - out_df.loc[~out_df.NR1.isnull(), &#34;NV1&#34;].astype(int)
        out_df.loc[~out_df.NR1.isnull(), &#34;RAF1&#34;] = out_df.loc[
            ~out_df.NR1.isnull(), &#34;NRef1&#34;
        ].astype(int) / out_df.loc[~out_df.NR1.isnull(), &#34;NR1&#34;].astype(int)

        # recombine columns
        for col in [&#34;VAF&#34;, &#34;NRef&#34;, &#34;RAF&#34;, &#34;NR&#34;, &#34;NV&#34;]:
            out_df.loc[~out_df.NR1.isnull(), col] = (
                out_df.loc[~out_df.NR1.isnull(), col].astype(str)
                + &#34;;&#34;
                + out_df.loc[~out_df.NR1.isnull(), &#34;{}1&#34;.format(col)].astype(str)
            )

        out_df.drop(columns=[&#34;VAF1&#34;, &#34;NRef1&#34;, &#34;RAF1&#34;, &#34;NR1&#34;, &#34;NV1&#34;], inplace=True)

    # if no need to split, easy calculations
    else:
        out_df[&#34;VAF&#34;] = out_df[&#34;NV&#34;].astype(int) / out_df[&#34;NR&#34;].astype(int)
        out_df[&#34;NRef&#34;] = out_df[&#34;NR&#34;].astype(int) - out_df[&#34;NV&#34;].astype(int)
        out_df[&#34;RAF&#34;] = out_df[&#34;NRef&#34;] / out_df[&#34;NR&#34;].astype(int)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="utils.calc_frequencies"><code class="name flex">
<span>def <span class="ident">calc_frequencies</span></span>(<span>out_df)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate variant and reference allele frequencies (VAF and RAF)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>out_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>DataFrame containing annotations and columns <code>["NR","NV"]</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>out_df</code> is edited in place, adding "NRef", "VAF" and "RAF" columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_frequencies(out_df):
    &#34;&#34;&#34;
    Calculate variant and reference allele frequencies (VAF and RAF)

    Parameters
    ----------
    out_df : `pd.DataFrame`
        DataFrame containing annotations and columns `[&#34;NR&#34;,&#34;NV&#34;]`

    Returns
    -------
    `out_df` is edited in place, adding &#34;NRef&#34;, &#34;VAF&#34; and &#34;RAF&#34; columns
    &#34;&#34;&#34;
    # split values if needed
    if out_df.NR.astype(str).str.contains(&#34;;&#34;).any():
        out_df[[&#34;NR&#34;, &#34;NR1&#34;]] = out_df[&#34;NR&#34;].astype(str).str.split(&#34;;&#34;, expand=True)
        out_df[[&#34;NV&#34;, &#34;NV1&#34;]] = out_df[&#34;NV&#34;].astype(str).str.split(&#34;;&#34;, expand=True)

        out_df[&#34;VAF&#34;] = out_df[&#34;NV&#34;].astype(int) / out_df[&#34;NR&#34;].astype(int)
        out_df[&#34;NRef&#34;] = out_df[&#34;NR&#34;].astype(int) - out_df[&#34;NV&#34;].astype(int)
        out_df[&#34;RAF&#34;] = out_df[&#34;NRef&#34;] / out_df[&#34;NR&#34;].astype(int)

        out_df.loc[~out_df.NR1.isnull(), &#34;VAF1&#34;] = out_df.loc[
            ~out_df.NR1.isnull(), &#34;NV1&#34;
        ].astype(int) / out_df.loc[~out_df.NR1.isnull(), &#34;NR1&#34;].astype(int)
        out_df.loc[~out_df.NR1.isnull(), &#34;NRef1&#34;] = out_df.loc[
            ~out_df.NR1.isnull(), &#34;NR1&#34;
        ].astype(int) - out_df.loc[~out_df.NR1.isnull(), &#34;NV1&#34;].astype(int)
        out_df.loc[~out_df.NR1.isnull(), &#34;RAF1&#34;] = out_df.loc[
            ~out_df.NR1.isnull(), &#34;NRef1&#34;
        ].astype(int) / out_df.loc[~out_df.NR1.isnull(), &#34;NR1&#34;].astype(int)

        # recombine columns
        for col in [&#34;VAF&#34;, &#34;NRef&#34;, &#34;RAF&#34;, &#34;NR&#34;, &#34;NV&#34;]:
            out_df.loc[~out_df.NR1.isnull(), col] = (
                out_df.loc[~out_df.NR1.isnull(), col].astype(str)
                + &#34;;&#34;
                + out_df.loc[~out_df.NR1.isnull(), &#34;{}1&#34;.format(col)].astype(str)
            )

        out_df.drop(columns=[&#34;VAF1&#34;, &#34;NRef1&#34;, &#34;RAF1&#34;, &#34;NR1&#34;, &#34;NV1&#34;], inplace=True)

    # if no need to split, easy calculations
    else:
        out_df[&#34;VAF&#34;] = out_df[&#34;NV&#34;].astype(int) / out_df[&#34;NR&#34;].astype(int)
        out_df[&#34;NRef&#34;] = out_df[&#34;NR&#34;].astype(int) - out_df[&#34;NV&#34;].astype(int)
        out_df[&#34;RAF&#34;] = out_df[&#34;NRef&#34;] / out_df[&#34;NR&#34;].astype(int)</code></pre>
</details>
</dd>
<dt id="utils.extract_alt"><code class="name flex">
<span>def <span class="ident">extract_alt</span></span>(<span>d, alt_obj, alt_key='ALT')</span>
</code></dt>
<dd>
<div class="desc"><p>Given a dictionary containing <code>vcf.model._Substitution</code> object, unpack
values into dictionary</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with "ALT" key to unpack</dd>
<dt><strong><code>alt_obj</code></strong> :&ensp;<code>vcf.model._Substitution</code> or <code>list</code></dt>
<dd>PyVCF <code>vcf.model._Substitution</code> object to extract information from
(i.e. <code>record.ALT</code>)</dd>
<dt><strong><code>alt_key</code></strong> :&ensp;<code>str</code>, optional <code>(default="ALT")</code></dt>
<dd>key within <code>d</code> containing PyVCF <code>model._Substitution</code> object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d_unpacked</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with unpacked values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_alt(d, alt_obj, alt_key=&#34;ALT&#34;):
    &#34;&#34;&#34;
    Given a dictionary containing `vcf.model._Substitution` object, unpack
    values into dictionary

    Parameters
    ----------
    d : `dict`
        Dictionary with &#34;ALT&#34; key to unpack
    alt_obj : `vcf.model._Substitution` or `list`
        PyVCF `vcf.model._Substitution` object to extract information from
        (i.e. `record.ALT`)
    alt_key : `str`, optional (default=&#34;ALT&#34;)
        key within `d` containing PyVCF `model._Substitution` object

    Returns
    -------
    d_unpacked : `dict`
        Dictionary with unpacked values
    &#34;&#34;&#34;
    d_unpacked = d.copy()

    if isinstance(alt_obj, vcf.model._Substitution):
        # get variant type from alt_key
        d_unpacked[&#34;{}_type&#34;.format(alt_key)] = alt_obj.type
        # get variant sequence as string and replace alt_key
        d_unpacked[alt_key] = alt_obj.sequence
    elif isinstance(alt_obj, list):
        # unpack list of ALTs
        d_unpacked[&#34;{}_type&#34;.format(alt_key)] = &#34;;&#34;.join([x.type for x in alt_obj])
        d_unpacked[alt_key] = &#34;;&#34;.join([x.sequence for x in alt_obj])
    else:
        print(&#34;alt_obj is not a list or vcf.model._Substitution object; skipping.&#34;)

    return d_unpacked</code></pre>
</details>
</dd>
<dt id="utils.extract_call"><code class="name flex">
<span>def <span class="ident">extract_call</span></span>(<span>call_obj, format_str='GT:GL:GOF:GQ:NR:NV', format_delim=':')</span>
</code></dt>
<dd>
<div class="desc"><p>Given a <code>vcf.model._Call</code> object, unpack values into dictionary</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>call_obj</code></strong> :&ensp;<code>vcf.model._Call</code></dt>
<dd>PyVCF <code>model._Call</code> object to extract information from</dd>
<dt><strong><code>format_str</code></strong> :&ensp;<code>str</code>, optional <code>(default="GT:GL:GOF:GQ:NR:NV")</code></dt>
<dd>String describing format of <code>vcf.model._Call</code> object, and keys present</dd>
<dt><strong><code>format_delim</code></strong> :&ensp;<code>str</code>, optional <code>(default=":")</code></dt>
<dd>String to delimit list values in <code>format_str</code> with</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>call_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with unpacked values from <code>call_obj</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_call(call_obj, format_str=&#34;GT:GL:GOF:GQ:NR:NV&#34;, format_delim=&#34;:&#34;):
    &#34;&#34;&#34;
    Given a `vcf.model._Call` object, unpack values into dictionary

    Parameters
    ----------
    call_obj : `vcf.model._Call`
        PyVCF `model._Call` object to extract information from
    format_str : `str`, optional (default=&#34;GT:GL:GOF:GQ:NR:NV&#34;)
        String describing format of `vcf.model._Call` object, and keys present
    format_delim : `str`, optional (default=&#34;:&#34;)
        String to delimit list values in `format_str` with

    Returns
    -------
    call_dict : `dict`
        Dictionary with unpacked values from `call_obj`
    &#34;&#34;&#34;
    assert isinstance(
        call_obj, vcf.model._Call
    ), &#34;call_obj must be a vcf.model._Call object&#34;
    call_dict = {}  # initialize empty dictionary
    keys = format_str.split(format_delim)  # list of expected keys in call_obj
    for key in keys:
        call_dict[key] = getattr(call_obj.data, key)

    return call_dict</code></pre>
</details>
</dd>
<dt id="utils.overlap_get"><code class="name flex">
<span>def <span class="ident">overlap_get</span></span>(<span>record, server='https://grch37.rest.ensembl.org')</span>
</code></dt>
<dd>
<div class="desc"><p>Given a <code>vcf.model._Record</code> object, send POST request to Ensembl
vep/:species/region</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>vcf.model._Record</code></dt>
<dd>PyVCF <code>model._Record</code> object to send to Ensembl API</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>str</code>, optional <code>(default="https://grch37.rest.ensembl.org")</code></dt>
<dd>URL to Ensembl server</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>overlap_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with returned values from Ensembl API call</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlap_get(record, server=&#34;https://grch37.rest.ensembl.org&#34;):
    &#34;&#34;&#34;
    Given a `vcf.model._Record` object, send POST request to Ensembl
    vep/:species/region

    Parameters
    ----------
    record : `vcf.model._Record`
        PyVCF `model._Record` object to send to Ensembl API
    server : `str`, optional (default=&#34;https://grch37.rest.ensembl.org&#34;)
        URL to Ensembl server

    Returns
    -------
    overlap_dict : `dict`
        Dictionary with returned values from Ensembl API call
    &#34;&#34;&#34;
    assert isinstance(
        record, vcf.model._Record
    ), &#34;record must be a vcf.model._Record object&#34;
    ext = &#34;/overlap/region/homo_sapiens/{}:{}-{}?feature=gene&#34;.format(
        record.CHROM,
        record.start,
        record.end,
    )
    headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}
    r = requests.get(server + ext, headers=headers)

    if not r.ok:
        r.raise_for_status()
        sys.exit()

    overlap_dict = r.json()
    return overlap_dict</code></pre>
</details>
</dd>
<dt id="utils.process_record"><code class="name flex">
<span>def <span class="ident">process_record</span></span>(<span>record, index=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a <code>vcf.model._Record</code> object, annotate it and return as a dataframe</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>vcf.model._Record</code></dt>
<dd>PyVCF <code>model._Record</code> object to annotate</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code>, optional <code>(default=1)</code></dt>
<dd>Index of resulting <code>pd.DataFrame</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>record_unpacked</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Annotated dataframe row corresponding to <code>record</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_record(record, index=1):
    &#34;&#34;&#34;
    Given a `vcf.model._Record` object, annotate it and return as a dataframe

    Parameters
    ----------
    record : `vcf.model._Record`
        PyVCF `model._Record` object to annotate
    index : `int`, optional (default=1)
        Index of resulting `pd.DataFrame`

    Returns
    -------
    record_unpacked : `pd.DataFrame`
        Annotated dataframe row corresponding to `record`
    &#34;&#34;&#34;
    # unpack record into dictionary of depth 1
    record_unpacked = unpack_dict(record.__dict__)
    # unpack ALT allele objects
    record_unpacked = extract_alt(record_unpacked, alt_obj=record.ALT, alt_key=&#34;ALT&#34;)
    # unpack model._Call object
    call_dict = unpack_dict(
        extract_call(record_unpacked[&#34;samples&#34;], format_str=record_unpacked[&#34;FORMAT&#34;]),
    )
    # remove old keys
    del record_unpacked[&#34;samples&#34;]
    del record_unpacked[&#34;FORMAT&#34;]
    # merge dicts
    record_unpacked = {**record_unpacked, **call_dict}

    # get gene where mutation is
    overlap_dict = overlap_get(record)
    try:
        # first record
        record_unpacked[&#34;gene_id&#34;] = overlap_dict[0][&#34;gene_id&#34;]
        record_unpacked[&#34;gene_symbol&#34;] = overlap_dict[0][&#34;external_name&#34;]
        record_unpacked[&#34;gene_biotype&#34;] = overlap_dict[0][&#34;biotype&#34;]
        record_unpacked[&#34;gene_description&#34;] = overlap_dict[0][&#34;description&#34;]
        if len(overlap_dict) &gt; 1:
            for i in range(1, len(overlap_dict)):
                record_unpacked[&#34;gene_id{}&#34;.format(i)] = overlap_dict[i][&#34;gene_id&#34;]
                record_unpacked[&#34;gene_symbol{}&#34;.format(i)] = overlap_dict[i][
                    &#34;external_name&#34;
                ]
                record_unpacked[&#34;gene_biotype{}&#34;.format(i)] = overlap_dict[i][&#34;biotype&#34;]
                record_unpacked[&#34;gene_description{}&#34;.format(i)] = overlap_dict[i][
                    &#34;description&#34;
                ]
    except:
        print(&#34;No gene overlap found for {}&#34;.format(record))

    # call Ensembl VEP endpoint
    vep_dict = vep_region_post(
        record,
        hgvs=1,
        # protein=1,
        # uniprot=1,
        # GO=1,
        # vcf_string=1,
        # domains=1,
        distance=0,  # don&#39;t look for upstream/downstream effects for simplicity
    )
    # extract VEP info
    record_unpacked[&#34;most_severe_consequence&#34;] = vep_dict[&#34;most_severe_consequence&#34;]

    # get MAF and snp info if available
    if &#34;colocated_variants&#34; in vep_dict:
        for d in vep_dict[&#34;colocated_variants&#34;]:
            if &#34;minor_allele&#34; in d:
                record_unpacked[&#34;minor_allele&#34;] = d[&#34;minor_allele&#34;]
                record_unpacked[&#34;minor_allele_freq&#34;] = d[&#34;minor_allele_freq&#34;]
                record_unpacked[&#34;snp_id&#34;] = d[&#34;id&#34;]

    return pd.DataFrame(record_unpacked, index=[index])</code></pre>
</details>
</dd>
<dt id="utils.split_vals"><code class="name flex">
<span>def <span class="ident">split_vals</span></span>(<span>d, key, list_delim=';')</span>
</code></dt>
<dd>
<div class="desc"><p>Given a dictionary and key within it, split values into multiple keys</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Key within <code>d</code> to split</dd>
<dt><strong><code>list_delim</code></strong> :&ensp;<code>str</code>, optional <code>(default=";")</code></dt>
<dd>String to delimit list values in <code>d[key]</code> with</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with split values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_vals(d, key, list_delim=&#34;;&#34;):
    &#34;&#34;&#34;
    Given a dictionary and key within it, split values into multiple keys

    Parameters
    ----------
    d : `dict`
        Dictionary
    key : `str`
        Key within `d` to split
    list_delim : `str`, optional (default=&#34;;&#34;)
        String to delimit list values in `d[key]` with

    Returns
    -------
    d : `dict`
        Dictionary with split values
    &#34;&#34;&#34;
    assert list_delim in d[key], &#34;Key {} does not contain delimiter {}&#34;.format(
        key, list_delim
    )
    vals = d[key].split(list_delim)  # list of split values
    d[key] = vals[0]  # original key gets first value
    for i, val in enumerate(vals[1:]):
        # add key1, key2, etc. and corresponding values
        d[&#34;{}{}&#34;.format(key, i + 1)] = val</code></pre>
</details>
</dd>
<dt id="utils.unpack_dict"><code class="name flex">
<span>def <span class="ident">unpack_dict</span></span>(<span>d, list_delim=';', verbose=False, indent='')</span>
</code></dt>
<dd>
<div class="desc"><p>Given a dictionary, unpack values such that lists become singular.
Intended to prep dictionaries for pandas compatibility.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary to unpack</dd>
<dt><strong><code>list_delim</code></strong> :&ensp;<code>str</code>, optional <code>(default=";")</code></dt>
<dd>String to delimit list values in <code>d</code> with</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional <code>(default=</code>False<code>)</code></dt>
<dd>If <code>True</code>, print information when values are unpacked</dd>
<dt><strong><code>indent</code></strong> :&ensp;<code>str</code>, optional <code>(default="")</code></dt>
<dd>For pretty traceback. Ignored if <code>verbose==False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d_unpacked</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with unpacked values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack_dict(d, list_delim=&#34;;&#34;, verbose=False, indent=&#34;&#34;):
    &#34;&#34;&#34;
    Given a dictionary, unpack values such that lists become singular.
    Intended to prep dictionaries for pandas compatibility.

    Parameters
    ----------
    d : `dict`
        Dictionary to unpack
    list_delim : `str`, optional (default=&#34;;&#34;)
        String to delimit list values in `d` with
    verbose : `bool`, optional (default=`False`)
        If `True`, print information when values are unpacked
    indent : `str`, optional (default=&#34;&#34;)
        For pretty traceback. Ignored if `verbose==False`.

    Returns
    -------
    d_unpacked : `dict`
        Dictionary with unpacked values
    &#34;&#34;&#34;
    d_unpacked = d.copy()
    for key in d:
        if isinstance(d[key], list):
            # if key is a list, do some unpacking
            if len(d[key]) &gt; 1:
                # if value is list, join by list_delim
                d_unpacked[key] = [str(elem) for elem in d_unpacked[key]]
                d_unpacked[key] = list_delim.join(d_unpacked[key])
                if verbose:
                    print(
                        &#34;{}Joining key {} using delimiter {}&#34;.format(
                            indent, key, list_delim
                        )
                    )
            elif len(d_unpacked[key]) == 1:
                # if value is list with one element, unpack
                d_unpacked[key] = d_unpacked[key][0]
                if verbose:
                    print(
                        &#34;{}Unpacked 1 value from key {}: {}&#34;.format(
                            indent, key, d_unpacked[key]
                        )
                    )
            else:
                # if empty list (for some reason), remove the key
                del d_unpacked[key]
        elif isinstance(d[key], dict):
            # if key is another dict, do full unpacking
            if verbose:
                print(
                    &#34;{}Unpacking key {} as dictionary with {} keys&#34;.format(
                        indent, key, len(d_unpacked[key])
                    )
                )
            # generate new keys from dict
            unpacked_key = unpack_dict(
                d_unpacked[key],
                list_delim=list_delim,
                verbose=verbose,
                indent=&#34;{}\t&#34;.format(indent),
            )
            # delete original key-value pair
            del d_unpacked[key]
            # merge the two dicts
            d_unpacked = {**d_unpacked, **unpacked_key}
            if verbose:
                print(&#34;{}\tAdded {} keys to dict&#34;.format(indent, len(unpacked_key)))
        elif d[key] is None:
            # if empty value, just remove it
            del d_unpacked[key]

    return d_unpacked</code></pre>
</details>
</dd>
<dt id="utils.vep_region_post"><code class="name flex">
<span>def <span class="ident">vep_region_post</span></span>(<span>record, server='https://grch37.rest.ensembl.org', ext='/vep/homo_sapiens/region', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a <code>vcf.model._Record</code> object, send POST request to Ensembl
vep/:species/region</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>vcf.model._Record</code></dt>
<dd>PyVCF <code>model._Record</code> object to send to Ensembl API</dd>
<dt><strong><code>server</code></strong> :&ensp;<code>str</code>, optional <code>(default="https://grch37.rest.ensembl.org")</code></dt>
<dd>URL to Ensembl server</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, optional <code>(default="/vep/homo_sapiens/region")</code></dt>
<dd>URL extension for region annotation endpoint</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for VEP endpoint</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>vep_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with returned values from Ensembl API call</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vep_region_post(
    record,
    server=&#34;https://grch37.rest.ensembl.org&#34;,
    ext=&#34;/vep/homo_sapiens/region&#34;,
    **kwargs,
):
    &#34;&#34;&#34;
    Given a `vcf.model._Record` object, send POST request to Ensembl
    vep/:species/region

    Parameters
    ----------
    record : `vcf.model._Record`
        PyVCF `model._Record` object to send to Ensembl API
    server : `str`, optional (default=&#34;https://grch37.rest.ensembl.org&#34;)
        URL to Ensembl server
    ext : `str`, optional (default=&#34;/vep/homo_sapiens/region&#34;)
        URL extension for region annotation endpoint
    **kwargs
        Keyword arguments for VEP endpoint

    Returns
    -------
    vep_dict : `dict`
        Dictionary with returned values from Ensembl API call
    &#34;&#34;&#34;
    assert isinstance(
        record, vcf.model._Record
    ), &#34;record must be a vcf.model._Record object&#34;
    headers = {&#34;Content-Type&#34;: &#34;application/json&#34;, &#34;Accept&#34;: &#34;application/json&#34;}
    r = requests.post(
        server + ext,
        headers=headers,
        data=&#39;{{ &#34;variants&#34; : [&#34;{} {} {} {} {} . . .&#34;], {} }}&#39;.format(
            record.CHROM,
            record.POS,
            record.ID if record.ID is not None else &#34;.&#34;,
            record.REF,
            record.ALT[0].sequence,
            str(kwargs).replace(&#34;{&#34;, &#34;&#34;).replace(&#34;}&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#39;&#34;&#39;),
        ),
    )

    if not r.ok:
        r.raise_for_status()
        sys.exit()

    vep_dict = r.json()
    assert len(vep_dict) == 1, &#34;More than one VEP result returned!&#34;
    return vep_dict[0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="utils.calc_frequencies" href="#utils.calc_frequencies">calc_frequencies</a></code></li>
<li><code><a title="utils.extract_alt" href="#utils.extract_alt">extract_alt</a></code></li>
<li><code><a title="utils.extract_call" href="#utils.extract_call">extract_call</a></code></li>
<li><code><a title="utils.overlap_get" href="#utils.overlap_get">overlap_get</a></code></li>
<li><code><a title="utils.process_record" href="#utils.process_record">process_record</a></code></li>
<li><code><a title="utils.split_vals" href="#utils.split_vals">split_vals</a></code></li>
<li><code><a title="utils.unpack_dict" href="#utils.unpack_dict">unpack_dict</a></code></li>
<li><code><a title="utils.vep_region_post" href="#utils.vep_region_post">vep_region_post</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>